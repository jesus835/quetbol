<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>SmartVApp - Guardians of the Galaxy</title>
    <meta name="viewport" content="width=1920" />
    <style>
      :root {
        color-scheme: dark;
        font-family: "Roboto", "Segoe UI", sans-serif;
        --purple: #170424;
        --purple-light: #462869;
        --blue: #12a0ff;
        --white: #ffffff;
        --gray: #b7c0d1;
        --card-bg: rgba(17, 17, 30, 0.9);
      }

      * {
        box-sizing: border-box;
        -webkit-font-smoothing: antialiased;
      }

      body {
        margin: 0;
        padding: 0;
        --body-backdrop-url: url("https://image.tmdb.org/t/p/original/oqP1qEZccq5AD9TVTIaO6IGUj7o.jpg");
        background: radial-gradient(circle at 60% 40%, rgba(88, 20, 186, 0.55) 10%, rgba(4, 6, 15, 0.98) 65%),
          #04050f;
        color: var(--white);
        overflow: hidden;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        position: relative;
        z-index: 0;
        user-select: none;
        -webkit-user-select: none;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background: var(--body-backdrop-url) center / cover no-repeat;
        opacity: 0.75;
        filter: saturate(1.05) brightness(0.9);
        z-index: -2;
      }

      main {
        flex: 1;
        display: grid;
        grid-template-rows: auto 1fr;
        position: relative;
        isolation: isolate;
        overflow: hidden;
        padding-top: 160px;
      }

      header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 24px 60px;
        background: transparent;
        backdrop-filter: none;
        border-bottom: none;
        box-shadow: none;
        z-index: 50;
        user-select: none;
        -webkit-user-select: none;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 20px;
        user-select: none;
        -webkit-user-select: none;
      }

      .brand-logo {
        width: 320px;
        height: 96px;
        border-radius: 18px;
        background: url("images/logo.png") center/contain no-repeat;
        display: block;
        margin-right: -160px;
        transform: translateX(-30%);
      }

      .brand-nav {
        display: flex;
        gap: 35px;
        font-size: 20px;
        text-transform: none;
        user-select: none;
        -webkit-user-select: none;
      }

      nav button,
      .profile button,
      .suggested-card {
        background: none;
        border: none;
        color: inherit;
        cursor: pointer;
        outline: none;
      }

      nav button,
      .profile button {
        position: relative;
        padding: 12px 18px;
        font-size: inherit;
        font-weight: 600;
        color: rgba(240, 242, 255, 0.78);
        border-radius: 999px;
        transition: background 180ms ease, color 180ms ease;
        outline: none;
      }

      .profile button {
        padding: 12px;
        width: 52px;
        height: 52px;
        display: grid;
        place-items: center;
        border-radius: 999px;
        background: rgba(32, 47, 115, 0.48);
        color: rgba(255, 255, 255, 0.85);
        font-size: 22px;
        box-shadow: 0 10px 26px rgba(12, 16, 40, 0.5);
      }

      nav button:focus-visible,
      nav button:hover,
      .profile button:focus-visible,
      .profile button:hover {
        background: rgba(255, 255, 255, 0.12);
        color: #ffffff;
      }

      .profile {
        display: flex;
        gap: 18px;
        align-items: center;
      }

      .profile .avatar {
        width: 55px;
        height: 55px;
        border-radius: 50%;
        background: url("https://i.pravatar.cc/100?img=18") center/cover no-repeat;
        outline: 3px solid rgba(255, 255, 255, 0.08);
        transition: outline 180ms ease, transform 120ms ease;
      }

      .profile .avatar:focus-visible {
        outline-color: rgba(88, 138, 255, 0.85);
        transform: translateY(-1px);
      }

      .hero {
        position: relative;
        display: flex;
        flex-direction: column;
        padding: 48px 48px 32px;
        gap: 32px;
        min-height: calc(100vh - 180px);
        user-select: none;
        -webkit-user-select: none;
      }

      body::after {
        content: "";
        position: fixed;
        inset: 0;
        background: linear-gradient(90deg, rgba(0, 0, 0, 0.88) 0%, rgba(0, 0, 0, 0.48) 42%, rgba(0, 0, 0, 0.1) 70%, rgba(0, 0, 0, 0) 100%);
        z-index: -1;
        pointer-events: none;
      }

      .hero-content {
        position: relative;
        z-index: 1;
        display: flex;
        flex-direction: column;
        gap: 28px;
        justify-content: center;
        flex: 1;
        max-width: 780px;
        transform: translate(10%, -8%) scale(1.2);
      }

      .hero-metadata {
        display: flex;
        align-items: center;
        gap: 18px;
        flex-wrap: wrap;
        font-size: 18px;
        font-weight: 600;
        letter-spacing: 0.01em;
        color: #ffffff;
      }

      .hero-metadata .tag-live[hidden],
      .hero-metadata .tag-time[hidden],
      .hero-metadata .tag-hour[hidden] {
        display: none !important;
      }

      .hero-metadata .tag-live {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 6px 18px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.92);
        color: #07122f;
        text-transform: uppercase;
        font-size: 15px;
        letter-spacing: 0.18em;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
      }

      .hero-metadata .tag-live .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #ff2d93;
        box-shadow: 0 0 0 4px rgba(255, 45, 147, 0.2);
      }

      .hero-metadata .tag {
        display: inline-flex;
        align-items: center;
        gap: 12px;
        color: rgba(255, 255, 255, 0.76);
        font-size: 17px;
        font-weight: 500;
        letter-spacing: 0.04em;
        position: relative;
        padding-left: 14px;
      }

      .hero-metadata .tag::before {
        content: "|";
        position: absolute;
        left: 0;
        color: rgba(255, 255, 255, 0.3);
      }

      .hero-metadata .tag.tag-time {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0;
        padding: 6px 24px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.92);
        color: #070b1f;
        text-transform: uppercase;
        font-size: 15px;
        font-weight: 600;
        letter-spacing: 0.14em;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
        transform: translateX(3%);
      }

      .hero-metadata .tag.tag-time::before {
        display: none;
      }

      .hero-metadata .tag.tag-hour {
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      .hero-title {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .hero-heading {
        margin: 0;
        font-size: 48px;
        font-weight: 700;
        letter-spacing: 0.02em;
        color: #ffffff;
        text-shadow: 0 12px 32px rgba(0, 0, 0, 0.65);
        white-space: nowrap;
        overflow: hidden;
      }

      .hero-flags {
        display: flex;
        align-items: center;
        gap: 18px;
        padding: 0;
        border-radius: 0;
        background: transparent;
        box-shadow: none;
        width: fit-content;
      }

      .hero-flag {
        width: 150px;
        height: auto;
        border-radius: 4px;
        object-fit: cover;
        box-shadow: none;
        border: 1px solid rgba(255, 255, 255, 0.18);
      }

      .hero-flag[data-asset-type="logo"] {
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 12px;
        object-fit: contain;
        border: 1px solid rgba(255, 255, 255, 0.24);
        border-radius: 12px;
      }

      .hero-flags[hidden] {
        display: none;
      }

      .hero-description {
        margin-top: 18px;
        display: inline-flex;
        align-items: center;
        gap: 16px;
        font-size: 0;
      }

      .hero-description .hero-action {
        font-size: 16px;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        padding: 20px 54px;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 150ms ease, opacity 120ms ease;
      }

      .hero-description .hero-action.tertiary {
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.85);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.16);
      }

      .hero-description .hero-action.tertiary:hover,
      .hero-description .hero-action.tertiary:focus-visible {
        background: rgba(255, 255, 255, 0.16);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.24);
      }

      .hero-description .hero-action:focus-visible {
        outline: 3px solid rgba(255, 255, 255, 0.75);
        outline-offset: 4px;
        box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.15), 0 14px 32px rgba(0, 0, 0, 0.45);
        transform: scale(1.05);
      }

      .hero-description .hero-action.primary {
        background: rgba(255, 255, 255, 0.92);
        color: #050b1f;
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45);
      }

      .hero-description .hero-action.secondary {
        background: rgba(255, 255, 255, 0.16);
        color: rgba(255, 255, 255, 0.85);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.25);
      }


      .hero-description .hero-action:hover {
        transform: translateY(-2px);
        opacity: 0.95;
        box-shadow: 0 20px 42px rgba(0, 0, 0, 0.5);
      }

      .hero-description .hero-action:focus-visible {
        outline: none;
      }

      .hero-bottom {
        position: relative;
        z-index: 1;
        display: flex;
        flex-direction: column;
        gap: 36px;
        transform: translateY(-18%) scale(1.45);
        transform-origin: top left;
        width: fit-content;
      }

      .section-header {
        position: relative;
        z-index: 2;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        padding-bottom: 12px;
        font-size: 18px;
        letter-spacing: 0.16em;
        text-transform: uppercase;
      }

      .section-header h2 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.22em;
        position: relative;
        top: 20px;
      }

      .section-header .section-link {
        background: rgba(255, 255, 255, 0.16);
        border: none;
        padding: 12px 28px;
        border-radius: 999px;
        font-size: 14px;
        letter-spacing: 0.18em;
        color: rgba(255, 255, 255, 0.85);
        text-transform: uppercase;
        cursor: pointer;
        transition: background 180ms ease, transform 120ms ease;
        outline: none;
      }

      .section-header .section-link:hover,
      .section-header .section-link:focus-visible {
        background: rgba(255, 255, 255, 0.24);
        color: var(--white);
        transform: translateY(-1px);
      }

      .suggested-grid {
        display: flex;
        gap: 32px;
        flex-wrap: nowrap;
        margin-top: 40px;
        transform: translateY(-13%);
        overflow-x: auto;
        padding: 12px 0 10px;
      }

      .trending-card-wrapper {
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 297px;
        flex: 0 0 auto;
      }

      .trending-card {
        position: relative;
        width: 100%;
        height: 165px;
        border-radius: 28px;
        background:
          linear-gradient(160deg, rgba(70, 40, 105, 0.35) 0%, rgba(10, 12, 28, 0.92) 80%);
        box-shadow: 0 24px 42px rgba(7, 10, 28, 0.45);
        border: none;
        overflow: hidden;
        isolation: isolate;
        transition: transform 140ms ease, box-shadow 140ms ease;
      }

      .trending-card::before {
        content: "";
        position: absolute;
        inset: 0;
        background-image: radial-gradient(rgba(255, 255, 255, 0.06) 1px, transparent 1px);
        background-size: 28px 28px;
        opacity: 0.6;
        pointer-events: none;
      }

      .trending-card::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: var(--event-image, none);
        background-size: cover;
        background-position: center;
        opacity: 0.55;
        mix-blend-mode: lighten;
        transition: opacity 180ms ease;
        z-index: -1;
        pointer-events: none;
      }

      .trending-card[data-has-image="false"]::after {
        opacity: 0;
      }

      .trending-card-badge {
        position: absolute;
        top: 20px;
        left: 20px;
        padding: 10px 18px;
        border-radius: 999px;
        background: #ffffff;
        color: #070b1f;
        font-size: 14px;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.25);
      }

      .trending-card-status {
        position: absolute;
        right: 24px;
        bottom: 24px;
        padding: 10px 22px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.16);
        color: rgba(255, 255, 255, 0.92);
        font-size: 13px;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.25);
        transform: translate(10%, 45%);
        will-change: transform;
      }

      .trending-card:hover,
      .trending-card:focus-visible {
        transform: translateY(-8px);
        box-shadow: 0 28px 56px rgba(5, 8, 20, 0.55);
      }

      .trending-card-title {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.02em;
        color: #ffffff;
        line-height: 1.08;
      }

      .trending-card-meta {
        margin: 0;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(219, 226, 248, 0.7);
        line-height: 1.12;
      }


      button:focus-visible,
      .profile .avatar:focus-visible {
        outline: 2px solid rgba(255, 255, 255, 0.65);
        outline-offset: 4px;
      }

      .trending-section {
        width: fit-content;
        display: flex;
        flex-direction: column;
      }

      .live-section {
        position: fixed;
        inset: 0;
        padding: 120px 80px 60px;
        background: rgba(6, 8, 18, 0.94);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        gap: 32px;
        z-index: 43;
        overflow-y: auto;
      }

      .live-section[data-open="true"] {
        display: flex;
      }

      .live-card {
        width: min(1200px, 100%);
        background: rgba(17, 17, 30, 0.92);
        border-radius: 28px;
        box-shadow: 0 24px 52px rgba(7, 10, 28, 0.55);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .live-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        padding: 32px 40px 24px;
        background: rgba(17, 17, 30, 0.92);
      }

      .live-header h2 {
        margin: 0;
        font-size: 22px;
        letter-spacing: 0.18em;
        text-transform: uppercase;
      }

      .live-description {
        margin: 8px 0 0;
        font-size: 14px;
        letter-spacing: 0.05em;
        color: rgba(219, 226, 248, 0.75);
      }

      .live-controls {
        display: flex;
        gap: 12px;
      }

      .live-controls button {
        padding: 12px 28px;
        border-radius: 999px;
        border: none;
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.16);
        color: #ffffff;
        transition: transform 120ms ease, background 120ms ease;
      }

      .live-controls button:hover,
      .live-controls button:focus-visible {
        transform: translateY(-2px);
        outline: none;
        background: rgba(255, 255, 255, 0.24);
      }

      .live-content {
        padding: 24px 40px 32px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .live-content .matches-grid {
        margin-top: 0;
      }

      body.live-active main {
        visibility: hidden;
      }

      body.live-active .live-section {
        visibility: visible;
      }

      .matches-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 24px;
      }

      .matches-card {
        position: relative;
        width: 100%;
        min-height: 220px;
        padding: 28px 26px 24px;
        border-radius: 28px;
        background:
          linear-gradient(160deg, rgba(33, 48, 94, 0.65) 0%, rgba(12, 19, 39, 0.92) 80%),
          var(--card-bg);
        box-shadow: 0 24px 42px rgba(7, 10, 28, 0.45);
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        gap: 18px;
        overflow: hidden;
        isolation: isolate;
        transition: transform 120ms ease, box-shadow 150ms ease, border-color 150ms ease;
      }

      .matches-card::after {
        content: "";
        position: absolute;
        inset: 0;
        background-image: var(--event-image, none);
        background-size: cover;
        background-position: center;
        opacity: 0.45;
        mix-blend-mode: lighten;
        transition: opacity 180ms ease;
        z-index: -2;
        pointer-events: none;
      }

      .matches-card[data-has-image="false"]::after {
        opacity: 0;
      }

      .matches-card::before {
        content: "";
        position: absolute;
        inset: 0;
        background-image: radial-gradient(rgba(255, 255, 255, 0.08) 1px, transparent 1px);
        background-size: 22px 22px;
        opacity: 0.55;
        pointer-events: none;
        z-index: -1;
      }

      .matches-card:hover,
      .matches-card:focus-visible {
        transform: translateY(-6px);
        box-shadow: 0 28px 52px rgba(5, 8, 20, 0.55);
      }

      .matches-card-badge {
        position: absolute;
        top: 22px;
        left: 22px;
        padding: 10px 18px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.92);
        color: #040815;
        font-size: 13px;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.35);
      }

      .matches-card-status {
        position: absolute;
        right: 22px;
        bottom: 24px;
        padding: 10px 22px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.16);
        color: rgba(255, 255, 255, 0.92);
        font-size: 13px;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .matches-card.is-live .matches-card-status {
        background: #ff2d93;
        border-color: #ff2d93;
        box-shadow: 0 14px 36px rgba(255, 45, 147, 0.35);
      }

      .matches-card-info {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .matches-card-title {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.01em;
        color: #ffffff;
      }

      .matches-card-subtitle {
        margin: 0;
        font-size: 14px;
        letter-spacing: 0.05em;
        color: rgba(219, 226, 248, 0.78);
      }

      .matches-card-meta {
        margin: 0;
        font-size: 13px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: rgba(219, 226, 248, 0.65);
      }

      .matches-empty {
        margin: 0;
        font-size: 13px;
        letter-spacing: 0.08em;
        color: rgba(255, 255, 255, 0.45);
        text-transform: uppercase;
      }
      .schedule-section {
        position: fixed;
        inset: 0;
        padding: 120px 80px 60px;
        background: rgba(6, 8, 18, 0.94);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        gap: 32px;
        z-index: 45;
        overflow-y: auto;
      }

      .schedule-section[data-open="true"] {
        display: flex;
      }

      .schedule-card {
        width: min(1200px, 100%);
        background: rgba(17, 17, 30, 0.92);
        border-radius: 32px;
        padding: 36px 44px;
        box-shadow: 0 28px 60px rgba(5, 8, 20, 0.55);
        display: flex;
        flex-direction: column;
        gap: 32px;
      }

      .schedule-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
      }

      .schedule-header h2 {
        margin: 0;
        font-size: 30px;
        letter-spacing: 0.05em;
      }

      .schedule-description {
        margin: 8px 0 0;
        color: rgba(217, 223, 241, 0.78);
        letter-spacing: 0.04em;
        max-width: 620px;
      }

      .schedule-controls {
        display: flex;
        gap: 12px;
      }

      .schedule-controls button {
        padding: 12px 28px;
        border-radius: 999px;
        border: none;
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.16);
        color: #ffffff;
        transition: transform 120ms ease, background 120ms ease;
      }

      .schedule-controls button.primary {
        background: #2d7dff;
        box-shadow: 0 18px 36px rgba(29, 102, 255, 0.35);
      }

      .schedule-controls button:hover,
      .schedule-controls button:focus-visible {
        transform: translateY(-2px);
        outline: none;
        background: rgba(255, 255, 255, 0.24);
      }

      .schedule-controls button.primary:hover,
      .schedule-controls button.primary:focus-visible {
        background: #1b58d6;
      }

      .schedule-content {
        max-height: 60vh;
        overflow-y: auto;
        padding-right: 12px;
      }

      body.schedule-active main {
        visibility: hidden;
      }

      body.schedule-active .schedule-section {
        visibility: visible;
      }

      .all-section {
        position: fixed;
        inset: 0;
        padding: 96px 72px 48px;
        background:
          linear-gradient(180deg, rgba(8, 10, 24, 0.88) 0%, rgba(5, 7, 18, 0.95) 100%),
          var(--body-backdrop-url) center / cover no-repeat;
        display: none;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        gap: 32px;
        z-index: 42;
        overflow-y: auto;
      }

      .all-section[data-open="true"] {
        display: flex;
      }

      .all-card {
        width: 100%;
        background: transparent;
        border-radius: 32px;
        padding: 0;
        box-shadow: none;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        flex: 1 1 auto;
        min-height: 0;
      }

      .all-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        padding: 40px 48px 32px;
        background: transparent;
      }

      .all-content {
        flex: 1 1 auto;
        overflow-y: auto;
        padding: 32px 48px 32px;
        background: transparent;
      }

      .all-controls {
        display: flex;
        gap: 12px;
      }

      .all-controls button {
        padding: 12px 28px;
        border-radius: 999px;
        border: none;
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.16);
        color: #ffffff;
        transition: transform 120ms ease, background 120ms ease;
      }

      .all-controls button:hover,
      .all-controls button:focus-visible {
        transform: translateY(-2px);
        outline: none;
        background: rgba(255, 255, 255, 0.24);
      }

      body.all-active main {
        visibility: hidden;
      }

      body.all-active .all-section {
        visibility: visible;
      }

      .player-section {
        position: fixed;
        inset: 0;
        padding-top: 100px;
        background: rgba(6, 8, 18, 0.92);
        display: none;
        flex-direction: column;
        gap: 32px;
        align-items: center;
        justify-content: center;
        z-index: 40;
      }

      .player-section[data-open="true"] {
        display: flex;
      }

      .player-info {
        display: flex;
        flex-direction: column;
        gap: 18px;
        color: rgba(255, 255, 255, 0.9);
        text-align: left;
        max-width: 420px;
        padding: 32px 36px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 24px;
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.55);
        align-self: flex-start;
        margin-left: 80px;
        opacity: 1;
        transform: translateY(0);
        transition: opacity 180ms ease, transform 180ms ease;
        will-change: opacity, transform;
      }

      .player-info.is-hidden {
        opacity: 0;
        transform: translateY(-12px);
        pointer-events: none;
      }

      .player-media {
        position: fixed;
        inset: 0;
        z-index: -1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
      }

      .player-media iframe {
        width: 100vw;
        height: 100vh;
        border: none;
      }

      .player-media .player-empty {
        color: #ffffff;
        font-size: 18px;
        background: rgba(0, 0, 0, 0.6);
        padding: 24px 32px;
        border-radius: 16px;
      }

      .player-info h2 {
        margin: 0;
        font-size: 28px;
        letter-spacing: 0.04em;
      }

      .player-info p {
        margin: 0;
        line-height: 1.6;
        color: rgba(217, 223, 241, 0.78);
      }

      .player-controls {
        display: flex;
        gap: 16px;
      }

      .player-controls button {
        padding: 14px 28px;
        border-radius: 999px;
        border: none;
        font-size: 15px;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.14);
        color: #fff;
        transition: transform 120ms ease, background 120ms ease;
      }

      .player-controls button.primary {
        background: #2d7dff;
        box-shadow: 0 18px 36px rgba(29, 102, 255, 0.35);
      }

      .player-controls button:hover,
      .player-controls button:focus-visible {
        transform: translateY(-2px);
        outline: none;
        background: rgba(255, 255, 255, 0.22);
      }

      .player-controls button.primary:hover,
      .player-controls button.primary:focus-visible {
        background: #1b58d6;
      }

      body.player-active main {
        visibility: hidden;
      }

      body.player-active .player-section {
        visibility: visible;
      }

      @media (max-width: 1600px) {
        .hero {
          grid-template-columns: 1fr 0.9fr;
        }

        .hero-title img {
          width: 280px;
        }
      }

      @media (max-width: 1366px) {
        body {
          transform: scale(0.85);
          transform-origin: top left;
        }
      }

      .brand-nav button.is-active {
        background: rgba(255, 255, 255, 0.22);
        color: #ffffff;
      }

      body.player-active header {
        visibility: hidden;
      }

      .player-sources {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
      }

      .player-sources button {
        padding: 10px 18px;
        border-radius: 999px;
        border: none;
        font-size: 13px;
        font-weight: 600;
        letter-spacing: 0.07em;
        text-transform: uppercase;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.14);
        color: rgba(255, 255, 255, 0.85);
        transition: transform 120ms ease, background 120ms ease;
      }

      .player-sources button.is-active {
        background: #2d7dff;
        color: #ffffff;
        box-shadow: 0 12px 24px rgba(29, 102, 255, 0.35);
      }

      .player-sources button:hover,
      .player-sources button:focus-visible {
        transform: translateY(-2px);
        background: rgba(255, 255, 255, 0.22);
        outline: none;
      }

      .player-info h2 {
        margin: 0;
        font-size: 28px;
        letter-spacing: 0.04em;
      }

      .player-current-match {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
        letter-spacing: 0.04em;
        color: rgba(255, 255, 255, 0.85);
      }

      .player-info p {
        margin: 0;
        line-height: 1.6;
        color: rgba(217, 223, 241, 0.78);
      }
    </style>
  </head>
  <body>
    <header>
      <div class="brand">
        <div class="brand-logo" tabindex="0" aria-label="Quetbol"></div>
        <nav class="brand-nav" aria-label="Secciones principales">
          <button tabindex="0">INICIO</button>
          <button tabindex="0" data-action="open-live">EN VIVO</button>
          <button tabindex="0" data-action="open-all">VER TODOS</button>
          <button tabindex="0">MI LISTA</button>
          <button tabindex="0" data-action="open-schedule">CALENDARIO</button>
          <button tabindex="0">NI√ëOS</button>
        </nav>
      </div>
      <div class="profile">
        <button tabindex="0" aria-label="Buscar">
          üîç
        </button>
        <button tabindex="0" aria-label="Notificaciones">
          üîî
        </button>
        <div class="avatar" tabindex="0" aria-label="Perfil"></div>
      </div>
    </header>

    <main>
      <section class="hero" aria-label="Contenido destacado">
        <div class="hero-content">
          <div class="hero-title">
            <div class="hero-flags" hidden aria-hidden="true">
              <img class="hero-flag" data-flag="home" loading="lazy" alt="" />
              <img class="hero-flag" data-flag="away" loading="lazy" alt="" />
            </div>
            <h1 class="hero-heading">Cargando partido...</h1>
            <div class="hero-metadata">
              <span class="tag-live" hidden aria-hidden="true"><span class="dot"></span>Live</span>
              <span class="tag tag-time" hidden></span>
              <span class="tag tag-hour" hidden></span>
              <span class="tag tag-league">Cargando liga...</span>
              <span class="tag tag-country">Cargando pa√≠s...</span>
            </div>
          </div>
          <p class="hero-description">
            <button class="hero-action primary" tabindex="0">Watch Now</button>
            <button class="hero-action secondary" tabindex="0">Details</button>
            <button class="hero-action tertiary" type="button" data-action="random-match" tabindex="0">
              Test Match
            </button>
          </p>
        </div>
        <div class="hero-bottom">
          <section class="trending-section" aria-label="Partidos pr√≥ximos">
            <div class="section-header">
              <h2>Tendencias</h2>
            </div>
            <div class="suggested-grid" data-trending-list></div>
            <p class="matches-empty" data-trending-empty>Sin partidos pr√≥ximos</p>
          </section>

        </div>
      </section>
    </main>
    <section class="live-section" aria-label="Partidos en vivo" aria-hidden="true" data-open="false">
      <div class="live-card">
        <div class="live-header">
          <div>
            <h2>En vivo ahora</h2>
            <p class="live-description">Partidos transmiti√©ndose en este momento.</p>
          </div>
          <div class="live-controls">
            <button type="button" class="live-close">Cerrar</button>
          </div>
        </div>
        <div class="live-content">
          <div class="matches-grid" data-live-list></div>
          <p class="matches-empty" data-live-empty>Sin partidos en vivo</p>
        </div>
      </div>
    </section>
    <section class="player-section" aria-label="Reproductor" aria-hidden="true" data-open="false">
      <div class="player-info">
        <h2>Reproduciendo ahora</h2>
        <p data-player-match class="player-current-match"></p>
        <p>
          Disfruta del contenido destacado con la mejor calidad disponible. Utiliza los controles
          inferiores para cambiar de fuente o cerrar esta vista.
        </p>
        <div class="player-controls">
          <button class="primary" type="button">Recargar</button>
          <button type="button" class="player-close">Cerrar</button>
        </div>
        <div class="player-sources" data-player-sources></div>
      </div>
      <div class="player-media" data-player-container></div>
    </section>
    <section class="all-section" aria-label="Todos los partidos" aria-hidden="true" data-open="false">
      <div class="all-card">
        <div class="all-header">
          <div>
            <h2>Todos los partidos de hoy</h2>
            <p class="schedule-description">
              Consulta la programaci√≥n completa del d√≠a y encuentra r√°pidamente el horario de cada encuentro.
            </p>
          </div>
          <div class="all-controls">
            <button type="button" class="all-close">Cerrar</button>
          </div>
        </div>
        <div class="all-content">
          <div class="matches-grid" data-all-list></div>
          <p class="matches-empty" data-all-empty>No hay partidos programados para hoy</p>
        </div>
      </div>
    </section>
    <section class="schedule-section" aria-label="Calendario de partidos" aria-hidden="true" data-open="false">
      <div class="schedule-card">
        <div class="schedule-header">
          <div>
            <h2>Calendario de hoy</h2>
            <p class="schedule-description">
              Explora todos los partidos programados y revisa r√°pidamente la hora de inicio de cada encuentro.
            </p>
          </div>
          <div class="schedule-controls">
            <button type="button" class="schedule-close">Cerrar</button>
          </div>
        </div>
        <div class="schedule-content">
          <div class="matches-grid">
            <div class="matches-card"><span class="matches-card-title">Arminia Bielefeld vs Karlsruher SC</span><span class="matches-card-meta">7:00 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Schalke 04 vs Elversberg</span><span class="matches-card-meta">7:00 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Hannover 96 vs Darmstadt 98</span><span class="matches-card-meta">7:00 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Chequia vs Burkina Faso</span><span class="matches-card-meta">7:30 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Blackburn Rovers vs Derby County</span><span class="matches-card-meta">7:30 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Uganda vs Chile</span><span class="matches-card-meta">7:30 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Tottenham Hotspur vs Manchester United</span><span class="matches-card-meta">7:30 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Mal√≠ vs Austria</span><span class="matches-card-meta">8:00 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Real Sociedad II vs Legan√©s</span><span class="matches-card-meta">8:00 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Girona vs Deportivo Alav√©s</span><span class="matches-card-meta">8:00 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Francia vs Canad√°</span><span class="matches-card-meta">8:30 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">NEOM vs Al Nassr</span><span class="matches-card-meta">8:50 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Lecce vs Hellas Verona</span><span class="matches-card-meta">9:00 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Como vs Cagliari</span><span class="matches-card-meta">9:00 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Trabzonspor vs Alanyaspor</span><span class="matches-card-meta">9:00 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Hoffenheim vs RB Leipzig</span><span class="matches-card-meta">9:30 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Hamburger SV vs Borussia Dortmund</span><span class="matches-card-meta">9:30 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Bayer Leverkusen vs Heidenheim</span><span class="matches-card-meta">9:30 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Union Berlin vs Bayern M√ºnchen</span><span class="matches-card-meta">9:30 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Al Shabab vs Al Ittifaq</span><span class="matches-card-meta">9:45 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Estados Unidos vs Tayikist√°n</span><span class="matches-card-meta">9:45 a.&nbsp;m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Stoke City vs Coventry City</span><span class="matches-card-meta">10:00 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">West Ham United vs Burnley</span><span class="matches-card-meta">10:00 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Everton vs Fulham</span><span class="matches-card-meta">10:00 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Sevilla vs Osasuna</span><span class="matches-card-meta">10:15 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Paraguay vs Panam√°</span><span class="matches-card-meta">10:15 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Huesca vs FC Andorra</span><span class="matches-card-meta">10:15 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Eibar vs Albacete</span><span class="matches-card-meta">10:15 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Excelsior vs Heracles</span><span class="matches-card-meta">10:30 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Alverca vs Rio Ave</span><span class="matches-card-meta">10:30 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">La Serena vs Universidad Cat√≥lica</span><span class="matches-card-meta">10:30 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Helmond Sport vs PSV II</span><span class="matches-card-meta">10:30 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Republic of Ireland vs Uzbekist√°n</span><span class="matches-card-meta">10:45 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Arabia Saudita vs Nueva Zelanda</span><span class="matches-card-meta">10:45 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Olympique Marseille vs Brest</span><span class="matches-card-meta">11:00 a.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Juventus vs Torino</span><span class="matches-card-meta">12:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Antalyaspor vs Be≈üikta≈ü</span><span class="matches-card-meta">12:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Al Ittihad vs Al-Ahli</span><span class="matches-card-meta">12:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Atl√©tico Madrid vs Levante</span><span class="matches-card-meta">12:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Borussia M'gladbach vs K√∂ln</span><span class="matches-card-meta">12:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Sunderland vs Arsenal</span><span class="matches-card-meta">12:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Deportivo La Coru√±a vs Cultural Leonesa</span><span class="matches-card-meta">12:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Volendam vs NAC Breda</span><span class="matches-card-meta">12:45 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Ayacucho vs Comerciantes Unidos</span><span class="matches-card-meta">1:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Uni√≥n Espa√±ola vs Colo-Colo</span><span class="matches-card-meta">1:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Le Havre vs Nantes</span><span class="matches-card-meta">1:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Tondela vs Vit√≥ria Guimar√£es</span><span class="matches-card-meta">1:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Manta vs Mushuc Runa</span><span class="matches-card-meta">2:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Always Ready vs ABB</span><span class="matches-card-meta">2:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Sport Recife vs Atl√©tico Mineiro</span><span class="matches-card-meta">2:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Novorizontino vs Remo</span><span class="matches-card-meta">2:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Danubio vs Plaza Colonia</span><span class="matches-card-meta">2:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Kaiserslautern vs Hertha BSC</span><span class="matches-card-meta">2:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Parma vs Milan</span><span class="matches-card-meta">2:45 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">M√°laga vs C√≥rdoba</span><span class="matches-card-meta">3:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Racing Club vs Defensa y Justicia</span><span class="matches-card-meta">3:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Chelsea vs Wolverhampton Wanderers</span><span class="matches-card-meta">3:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Brooklyn vs DC Power</span><span class="matches-card-meta">3:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Olimpia vs General Caballero JLM</span><span class="matches-card-meta">3:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Espanyol vs Villarreal</span><span class="matches-card-meta">3:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Monaco vs Lens</span><span class="matches-card-meta">3:05 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Juan Pablo II College vs Atl√©tico Grau</span><span class="matches-card-meta">3:15 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Palestino vs Coquimbo Unido</span><span class="matches-card-meta">3:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Santa Clara vs Sporting CP</span><span class="matches-card-meta">3:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Vasco da Gama vs Juventude</span><span class="matches-card-meta">4:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Minnesota United vs Seattle Sounders FC</span><span class="matches-card-meta">4:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Fortaleza CEIF vs Junior</span><span class="matches-card-meta">4:10 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Internacional vs Bahia</span><span class="matches-card-meta">4:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Independiente del Valle vs Universidad Cat√≥lica</span><span class="matches-card-meta">4:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Gualberto Villarroel SJ vs Real Oruro</span><span class="matches-card-meta">4:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Wanderers vs River Plate</span><span class="matches-card-meta">5:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Dallas Trinity vs Sporting JAX</span><span class="matches-card-meta">5:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Hurac√°n vs Newell's Old Boys</span><span class="matches-card-meta">5:15 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Talleres C√≥rdoba vs Platense</span><span class="matches-card-meta">5:15 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Estudiantes Caseros vs Estudiantes R√≠o Cuarto</span><span class="matches-card-meta">5:40 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Cincinnati vs Columbus Crew</span><span class="matches-card-meta">6:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Tigres UANL vs Atl√©tico San Luis</span><span class="matches-card-meta">6:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Guadalajara vs Monterrey</span><span class="matches-card-meta">6:07 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Atl√©tico Nacional vs Rionegro √Åguilas</span><span class="matches-card-meta">6:20 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">O'Higgins vs √ëublense</span><span class="matches-card-meta">6:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">LDU Quito vs Libertad</span><span class="matches-card-meta">7:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Independiente Petrolero vs Nacional Potos√≠</span><span class="matches-card-meta">7:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">S√£o Paulo vs RB Bragantino</span><span class="matches-card-meta">7:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Carolina Ascent vs Fort Lauderdale United</span><span class="matches-card-meta">7:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Deportivo Mor√≥n vs Deportivo Madryn</span><span class="matches-card-meta">7:10 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Uni√≥n Santa Fe vs Barracas Central</span><span class="matches-card-meta">7:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">San Mart√≠n San Juan vs Lan√∫s</span><span class="matches-card-meta">7:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Toluca vs Am√©rica</span><span class="matches-card-meta">8:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Inter Miami vs Nashville SC</span><span class="matches-card-meta">8:00 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Atl√©tico Bucaramanga vs La Equidad</span><span class="matches-card-meta">8:30 p.&nbsp.m.</span></div>
            <div class="matches-card"><span class="matches-card-title">Cruz Azul vs Pumas UNAM</span><span class="matches-card-meta">10:05 p.&nbsp.m.</span></div>
          </div>
        </div>
      </div>
    </section>
    <script>
      (() => {
        const API_URL = 'https://ftvhd.com/diaries.json';
        const heroHeading = document.querySelector('.hero-heading');
        const heroLeagueTag = document.querySelector('.tag-league');
        const heroCountryTag = document.querySelector('.tag-country');
        const heroLiveTag = document.querySelector('.tag-live');
        const heroTimeTag = document.querySelector('.tag-time');
        const heroHourTag = document.querySelector('.tag-hour');
        const trendingList = document.querySelector('[data-trending-list]');
        const trendingEmpty = document.querySelector('[data-trending-empty]');
        const liveList = document.querySelector('[data-live-list]');
        const liveEmpty = document.querySelector('[data-live-empty]');
        const allList = document.querySelector('[data-all-list]');
        const allEmpty = document.querySelector('[data-all-empty]');
        const allSection = document.querySelector('.all-section');
        const liveSection = document.querySelector('.live-section');
        const openAllButton = document.querySelector('[data-action="open-all"]');
        const openLiveButton = document.querySelector('[data-action="open-live"]');
        const allCloseButton = allSection?.querySelector('.all-close');
        const liveCloseButton = liveSection?.querySelector('.live-close');
        const heroFlagsContainer = document.querySelector('.hero-flags');
        const heroFlagHome = heroFlagsContainer?.querySelector('[data-flag="home"]');
        const heroFlagAway = heroFlagsContainer?.querySelector('[data-flag="away"]');
        const randomMatchButton = document.querySelector('[data-action="random-match"]');

        let currentHeroMatch = null;
        let currentPlayerMatch = null;
        let currentPlayerSourceIndex = 0;
        let currentPlayerSources = [];
        const matchElementMap = new WeakMap();
        const DEFAULT_BACKDROP_URL =
          'https://image.tmdb.org/t/p/original/oqP1qEZccq5AD9TVTIaO6IGUj7o.jpg';
        const EVENT_IMAGE_MAP = {};
        const EVENT_IMAGES_ENDPOINT =
          'https://script.google.com/macros/s/AKfycbznU_kPBIACTGRKHmW6Jf0o7V7iGE1ARhUx-WIO1LhQgmTgOP-gXhB3NTAOLws6SFV-/exec';
        const FLAG_CODES_ENDPOINT = 'https://flagcdn.com/es/codes.json';
        const FLAG_IMAGE_BASE = 'https://flagcdn.com/w320/';
        const CACHE_TTL_MS = 12 * 60 * 60 * 1000;
        const EVENT_IMAGES_STORAGE_KEY = 'smartvapp:event-images';
        const FLAG_CODES_STORAGE_KEY = 'smartvapp:flag-codes';
        const TEAM_LOGOS_STORAGE_KEY = 'smartvapp:team-logos';
        const SPORTSDB_API_BASE_V1 = 'https://www.thesportsdb.com/api/v1/json/123';
        const observedCompetitions = new Map();
        const flagNameToCode = new Map();
        const teamLogoCache = new Map();
        let flagCodesLoaded = false;
        let availableMatches = [];
        let liveMatchesPool = [];

        const heroTestMatches = [
          {
            matchName: 'Corea del Sur vs Costa de Marfil',
            competition: 'Copa Mundial Sub-17',
            country: 'Copa mundial sub20 fifa',
            isNational: true,
            timeLabel: 'Proximamente',
            hourLabel: '7:30 a.¬†m.',
            isLive: false,
            isTestMatch: true
          },
          {
            matchName: 'FC Barcelona vs Real Madrid',
            competition: 'LaLiga',
            country: 'Espa√±a',
            isNational: false,
            timeLabel: 'Pr√≥ximo',
            hourLabel: '9:00 p.¬†m.',
            isLive: false,
            isTestMatch: true
          },
          {
            matchName: 'Manchester City vs Bayern M√ºnchen',
            competition: 'UEFA Champions League',
            country: 'Europa',
            isNational: false,
            timeLabel: 'Pr√≥ximo',
            hourLabel: '8:45 p.¬†m.',
            isLive: false,
            isTestMatch: true
          },
          {
            matchName: 'Argentina vs Brasil',
            competition: 'Amistoso Internacional',
            country: 'CONMEBOL',
            isNational: true,
            timeLabel: 'En Vivo',
            hourLabel: '',
            isLive: true,
            isTestMatch: true
          },
          {
            matchName: 'Club Am√©rica vs Chivas Guadalajara',
            competition: 'Liga MX',
            country: 'M√©xico',
            isNational: false,
            timeLabel: 'Pr√≥ximo',
            hourLabel: '10:00 p.¬†m.',
            isLive: false,
            isTestMatch: true
          }
        ];

        const PRIORITY_TEAM_PATTERNS = [/real madrid/i, /barcelona/i];

        const TEAM_NAME_ALIASES = {
          'fc barcelona': 'Barcelona',
          barcelona: 'Barcelona',
          'real madrid': 'Real Madrid',
          'manchester city': 'Manchester City',
          'bayern m√ºnchen': 'Bayern Munich',
          'bayern munchen': 'Bayern Munich',
          'club am√©rica': 'Club America',
          'club america': 'Club America',
          'chivas guadalajara': 'CD Guadalajara',
          guadalajara: 'CD Guadalajara',
          'tigres uanl': 'Tigres',
          tigres: 'Tigres',
          'atl√©tico nacional': 'Atl√©tico Nacional',
          'atletico nacional': 'Atl√©tico Nacional'
        };

        const toTitleCase = text =>
          text.replace(/\w\S*/g, word => word.charAt(0).toUpperCase() + word.slice(1));

        const buildTeamQueryList = teamName => {
          const queries = new Set();
          if (teamName) {
            queries.add(teamName);
            const ascii = teamName
              .normalize('NFD')
              .replace(/[\u0300-\u036f]/g, '')
              .replace(/&/g, 'and')
              .replace(/\s+/g, ' ')
              .trim();
            if (ascii && ascii !== teamName) {
              queries.add(ascii);
            }
          }

          const normalized = normalizeText(teamName);
          if (normalized) {
            const alias = TEAM_NAME_ALIASES[normalized];
            if (alias) {
              queries.add(alias);
            }
            const words = normalized.split(' ').filter(Boolean);
            if (words.length) {
              const title = toTitleCase(words.join(' '));
              queries.add(title);
            }
          }

          return [...queries].filter(Boolean);
        };

        const normalizeEventName = value => {
          if (!value || typeof value !== 'string') return null;
          return value.replace(/\s+/g, ' ').trim().toLowerCase();
        };

        const getEventImageUrl = competition => {
          const normalized = normalizeEventName(competition);
          if (!normalized) return null;
          return EVENT_IMAGE_MAP[normalized] ?? null;
        };

        const registerCompetition = name => {
          if (!name) return;
          const normalized = normalizeEventName(name);
          if (!normalized) return;
          if (!observedCompetitions.has(normalized)) {
            observedCompetitions.set(normalized, name.trim());
          }
        };

        const clearObject = target => {
          if (!target || typeof target !== 'object') return;
          Object.keys(target).forEach(key => {
            delete target[key];
          });
        };

        const updateBodyBackdrop = match => {
          const target =
            match?.competition ?? match?.country ?? match?.matchName ?? null;
          const imageUrl = target ? getEventImageUrl(target) : null;
          const url = imageUrl ?? DEFAULT_BACKDROP_URL;
          document.body?.style.setProperty('--body-backdrop-url', `url("${url}")`);
        };

        const normalizeText = value => {
          if (!value || typeof value !== 'string') return null;
          return value
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .toLowerCase()
            .replace(/[^a-z0-9\s-]/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
        };

        const sanitizeTeamName = value => {
          const normalized = normalizeText(value);
          if (!normalized) return null;
          return normalized
            .replace(/\bsub[-\s]?\d+\b/g, '')
            .replace(/\bu\d+\b/g, '')
            .replace(/\bjuvenil(es)?\b/g, '')
            .replace(/\b(femenin[ao]s?|women|girls|masculin[ao]s?|men)\b/g, '')
            .replace(/\bseleccion\b/g, '')
            .replace(/\bnacional\b/g, '')
            .replace(/\b(?:team|club|fc|sc|cf)\b/g, '')
            .replace(/\b(?:de|del|la|el|los|las|the)\b/g, match => ` ${match.trim()} `)
            .replace(/\s+/g, ' ')
            .trim();
        };

        const FLAG_NAME_ALIASES = {
          'corea del sur': 'kr',
          'corea del norte': 'kp',
          'republica de corea': 'kr',
          'republica popular democratica de corea': 'kp',
          'republica de irlanda': 'ie',
          irlanda: 'ie',
          escocia: 'gb-sct',
          gales: 'gb-wls',
          inglaterra: 'gb-eng',
          'inglaterra femenina': 'gb-eng',
          'reinounido': 'gb',
          'reino unido': 'gb',
          estadosunidos: 'us',
          'estados unidos': 'us',
          'costa de marfil': 'ci',
          'tunez': 'tn',
          'costa rica': 'cr',
          'republica checa': 'cz',
          chequia: 'cz',
          'antigua y barbuda': 'ag',
          'emiratos arabes unidos': 'ae',
          'arabia saudita': 'sa',
          'republica dominicana': 'do',
          'bosnia y herzegovina': 'ba',
          'bosnia-herzegovina': 'ba',
          'hong kong': 'hk',
          'macedonia del norte': 'mk',
          'cabo verde': 'cv',
          siria: 'sy',
          taiwan: 'tw',
          china: 'cn'
        };

        const registerFlagAlias = (name, code) => {
          const normalizedName = sanitizeTeamName(name);
          if (!normalizedName || !code) return;
          flagNameToCode.set(normalizedName, code.toLowerCase());
        };

        const registerFlagName = (name, code) => {
          registerFlagAlias(name, code);
          const compact = sanitizeTeamName(name?.replace(/\s+/g, ''));
          if (compact) flagNameToCode.set(compact, code.toLowerCase());
        };

        const findFlagCode = teamName => {
          const sanitized = sanitizeTeamName(teamName);
          if (!sanitized) return null;
          if (flagNameToCode.has(sanitized)) {
            return flagNameToCode.get(sanitized);
          }
          const compact = sanitized.replace(/\s+/g, '');
          if (flagNameToCode.has(compact)) {
            return flagNameToCode.get(compact);
          }
          if (sanitized.includes(' ')) {
            const parts = sanitized.split(' ');
            for (let i = parts.length; i >= 1; i -= 1) {
              const candidate = parts.slice(0, i).join(' ');
              if (flagNameToCode.has(candidate)) {
                return flagNameToCode.get(candidate);
              }
            }
          }
          return null;
        };

        const extractTeams = matchName => {
          if (!matchName || typeof matchName !== 'string') return [];
          const cleaned = matchName.replace(/\s+/g, ' ').trim();
          const parts = cleaned
            .split(/\s+(?:vs\.?|v|contra)\s+|\s+[‚Äì‚Äî-]\s+/i)
            .map(part => part.trim())
            .filter(Boolean);
          if (parts.length >= 2) {
            return [parts[0], parts[1]];
          }
          return [];
        };

        const buildFlagUrl = code => {
          if (!code) return null;
          return `${FLAG_IMAGE_BASE}${code.toLowerCase()}.png`;
        };

        const hideHeroAssets = () => {
          if (!heroFlagsContainer || !heroFlagHome || !heroFlagAway) return;
          heroFlagHome.src = '';
          heroFlagHome.alt = '';
          heroFlagAway.src = '';
          heroFlagAway.alt = '';
          heroFlagHome.removeAttribute('data-asset-type');
          heroFlagAway.removeAttribute('data-asset-type');
           heroFlagsContainer.setAttribute('data-test-match', 'false');
          heroFlagsContainer.hidden = true;
          heroFlagsContainer.setAttribute('aria-hidden', 'true');
        };

        const updateHeroFlags = match => {
          if (!heroFlagsContainer || !heroFlagHome || !heroFlagAway) return;
          const teams = extractTeams(match?.matchName ?? '');
          if (!teams.length) {
            hideHeroAssets();
            return;
          }
          heroFlagsContainer.setAttribute(
            'data-test-match',
            match?.isTestMatch ? 'true' : 'false'
          );
          if (teams.length < 2) {
            hideHeroAssets();
            return;
          }

          const nationalAssets = teams
            .map(team => {
              const code = findFlagCode(team);
              if (!code) return null;
              const url = buildFlagUrl(code);
              return url ? { type: 'flag', team, url } : null;
            })
            .filter(Boolean);

          if (nationalAssets.length === teams.length) {
            applyHeroAssets(nationalAssets);
            return;
          }

          Promise.all(
            teams.map(async team => {
              const code = findFlagCode(team);
              if (code) {
                const url = buildFlagUrl(code);
                if (url) {
                  return { type: 'flag', team, url };
                }
              }
              if (match?.isTestMatch && match.isNational) {
                return null;
              }
              const logoUrl = await fetchTeamLogo(team);
              if (logoUrl) {
                return { type: 'logo', team, url: logoUrl };
              }
              return null;
            })
          )
            .then(results => {
              const valid = results.filter(Boolean);
              if (valid.length === teams.length) {
                applyHeroAssets(valid);
              } else {
                hideHeroAssets();
              }
            })
            .catch(() => {
              hideHeroAssets();
            });
        };

        const setHeroMatch = match => {
          if (!match) return;
          currentHeroMatch = match;
          heroHeading.textContent = match.matchName ?? 'Partido';
          if (heroLeagueTag) {
            heroLeagueTag.textContent = match.competition ?? '';
          }
          if (heroCountryTag) {
            heroCountryTag.textContent = match.country ?? '';
          }
          if (heroTimeTag) {
            const timeLabel = match.timeLabel ?? '';
            heroTimeTag.textContent = timeLabel;
            heroTimeTag.hidden = !timeLabel;
            heroTimeTag.setAttribute('aria-hidden', String(!timeLabel));
          }
          if (heroHourTag) {
            const hourLabel = match.hourLabel ?? '';
            heroHourTag.textContent = hourLabel;
            heroHourTag.hidden = !hourLabel;
            heroHourTag.setAttribute('aria-hidden', String(!hourLabel));
          }
          if (heroLiveTag && typeof match.isLive === 'boolean') {
            heroLiveTag.hidden = !match.isLive;
            heroLiveTag.setAttribute('aria-hidden', String(!match.isLive));
          }
          updateBodyBackdrop(match);
          updateHeroFlags(match);
        };

        const computeHeroContext = (match, now = new Date()) => {
          if (!match) return null;
          const formattedTime = match.dateTime ? formatTime(match.dateTime) : null;
          const isLive =
            match.dateTime &&
            match.date === now.toISOString().slice(0, 10) &&
            match.dateTime.getTime() <= now.getTime() &&
            now.getTime() - match.dateTime.getTime() <= 2 * 60 * 60 * 1000;
          return {
            ...match,
            timeLabel: !isLive ? 'Proximamente' : '',
            hourLabel: formattedTime ?? '',
            isLive,
            isTestMatch: false
          };
        };

        const loadEventImagesFromCache = () => {
          if (typeof window === 'undefined' || !window.localStorage) return false;
          try {
            const raw = window.localStorage.getItem(EVENT_IMAGES_STORAGE_KEY);
            if (!raw) return false;
            const payload = JSON.parse(raw);
            if (
              !payload ||
              typeof payload !== 'object' ||
              typeof payload.timestamp !== 'number' ||
              Date.now() - payload.timestamp > CACHE_TTL_MS ||
              typeof payload.images !== 'object' ||
              payload.images === null
            ) {
              return false;
            }
            clearObject(EVENT_IMAGE_MAP);
            Object.assign(EVENT_IMAGE_MAP, payload.images);
            return Object.keys(EVENT_IMAGE_MAP).length > 0;
          } catch (error) {
            console.warn('No se pudo leer la cach√© de im√°genes de eventos.', error);
            return false;
          }
        };

        const persistEventImages = () => {
          if (typeof window === 'undefined' || !window.localStorage) return;
          try {
            const payload = {
              timestamp: Date.now(),
              images: { ...EVENT_IMAGE_MAP }
            };
            window.localStorage.setItem(EVENT_IMAGES_STORAGE_KEY, JSON.stringify(payload));
          } catch (error) {
            console.warn('No se pudo guardar la cach√© de im√°genes de eventos.', error);
          }
        };

        const loadFlagCodesFromCache = () => {
          if (typeof window === 'undefined' || !window.localStorage) return false;
          try {
            const raw = window.localStorage.getItem(FLAG_CODES_STORAGE_KEY);
            if (!raw) return false;
            const payload = JSON.parse(raw);
            if (
              !payload ||
              typeof payload !== 'object' ||
              typeof payload.timestamp !== 'number' ||
              Date.now() - payload.timestamp > CACHE_TTL_MS ||
              !Array.isArray(payload.entries)
            ) {
              return false;
            }
            flagNameToCode.clear();
            payload.entries.forEach(entry => {
              if (!Array.isArray(entry)) return;
              const [name, code] = entry;
              if (typeof name === 'string' && typeof code === 'string') {
                flagNameToCode.set(name, code);
              }
            });
            return flagNameToCode.size > 0;
          } catch (error) {
            console.warn('No se pudo leer la cach√© de c√≥digos de banderas.', error);
            return false;
          }
        };

        const persistFlagCodes = () => {
          if (typeof window === 'undefined' || !window.localStorage) return;
          try {
            const entries = Array.from(flagNameToCode.entries());
            window.localStorage.setItem(
              FLAG_CODES_STORAGE_KEY,
              JSON.stringify({ timestamp: Date.now(), entries })
            );
          } catch (error) {
            console.warn('No se pudo guardar la cach√© de c√≥digos de banderas.', error);
          }
        };

        const applyFlagAliases = () => {
          Object.entries(FLAG_NAME_ALIASES).forEach(([name, code]) => {
            registerFlagAlias(name, code);
          });
        };

        const findPriorityMatch = (list, patterns = PRIORITY_TEAM_PATTERNS) => {
          if (!Array.isArray(list) || !list.length) return null;
          return list.find(match =>
            patterns.some(pattern => pattern.test(match?.matchName ?? ''))
          );
        };

        const pickRandomMatch = () => {
          const now = new Date();
          if (liveMatchesPool.length) {
            const priorityLive = findPriorityMatch(liveMatchesPool);
            const baseLive =
              priorityLive ??
              liveMatchesPool[Math.floor(Math.random() * liveMatchesPool.length)];
            return computeHeroContext(baseLive, now);
          }
          if (availableMatches.length) {
            const priorityAvailable = findPriorityMatch(availableMatches);
            const baseMatch =
              priorityAvailable ??
              availableMatches[Math.floor(Math.random() * availableMatches.length)];
            return computeHeroContext(baseMatch, now);
          }
          if (heroTestMatches.length) {
            const fallbackIndex = Math.floor(Math.random() * heroTestMatches.length);
            return heroTestMatches[fallbackIndex];
          }
          return null;
        };

        const normalizeTeamKey = value => {
          const sanitized = sanitizeTeamName(value);
          if (!sanitized) return null;
          return sanitized.replace(/\s+/g, '_');
        };

        const loadTeamLogosFromCache = () => {
          if (typeof window === 'undefined' || !window.localStorage) return false;
          try {
            const raw = window.localStorage.getItem(TEAM_LOGOS_STORAGE_KEY);
            if (!raw) return false;
            const payload = JSON.parse(raw);
            if (
              !payload ||
              typeof payload !== 'object' ||
              typeof payload.timestamp !== 'number' ||
              Date.now() - payload.timestamp > CACHE_TTL_MS ||
              typeof payload.logos !== 'object' ||
              payload.logos === null
            ) {
              return false;
            }
            teamLogoCache.clear();
            Object.entries(payload.logos).forEach(([key, value]) => {
              if (typeof value === 'string' && value) {
                teamLogoCache.set(key, value);
              }
            });
            return teamLogoCache.size > 0;
          } catch (error) {
            console.warn('No se pudo leer la cach√© de logos de equipos.', error);
            return false;
          }
        };

        const persistTeamLogos = () => {
          if (typeof window === 'undefined' || !window.localStorage) return;
          try {
            const payload = {
              timestamp: Date.now(),
              logos: Object.fromEntries(teamLogoCache.entries())
            };
            window.localStorage.setItem(TEAM_LOGOS_STORAGE_KEY, JSON.stringify(payload));
          } catch (error) {
            console.warn('No se pudo guardar la cach√© de logos de equipos.', error);
          }
        };

        const fetchTeamLogo = async teamName => {
          const key = normalizeTeamKey(teamName);
          if (!key) return null;
          if (!teamLogoCache.size) {
            loadTeamLogosFromCache();
          }
          if (teamLogoCache.has(key)) {
            return teamLogoCache.get(key);
          }
          const queries = buildTeamQueryList(teamName);
          for (const query of queries) {
            try {
              const url = `${SPORTSDB_API_BASE_V1}/searchteams.php?t=${encodeURIComponent(query)}`;
              const response = await fetch(url, { cache: 'no-store' });
              if (!response.ok) {
                throw new Error(`Estado ${response.status}`);
              }
              const payload = await response.json();
              const teams = Array.isArray(payload?.teams) ? payload.teams : [];
              if (!teams.length) continue;

              const bestMatch =
                teams.find(
                  item => sanitizeTeamName(item?.strTeam) === sanitizeTeamName(teamName)
                ) ?? teams[0];

              const logoUrl =
                bestMatch?.strTeamBadge ??
                bestMatch?.strTeamLogo ??
                bestMatch?.strTeamJersey ??
                null;

              if (logoUrl) {
                teamLogoCache.set(key, logoUrl);
                persistTeamLogos();
                return logoUrl;
              }
            } catch (error) {
              console.warn(`No fue posible obtener el logo para ${teamName} usando "${query}".`, error);
            }
          }
          return null;
        };

        const applyHeroAssets = assets => {
          if (!heroFlagsContainer || !heroFlagHome || !heroFlagAway) return;
          const [home, away] = assets;
          const apply = (element, asset) => {
            element.src = asset.url;
            element.alt =
              asset.type === 'flag'
                ? `Bandera de ${asset.team}`
                : `Escudo de ${asset.team}`;
            element.dataset.assetType = asset.type;
            element.setAttribute('data-team-name', asset.team);
          };
          apply(heroFlagHome, home);
          apply(heroFlagAway, away);
          heroFlagsContainer.hidden = false;
          heroFlagsContainer.setAttribute('aria-hidden', 'false');
        };

        const fetchFlagCodes = async () => {
          if (flagCodesLoaded) return;
          const cacheApplied = loadFlagCodesFromCache();
          applyFlagAliases();
          if (cacheApplied) {
            flagCodesLoaded = true;
            updateHeroFlags(currentHeroMatch);
            return;
          }
          try {
            const response = await fetch(FLAG_CODES_ENDPOINT, { cache: 'no-store' });
            if (!response.ok) {
              throw new Error(`Estado ${response.status}`);
            }
            const payload = await response.json();
            flagNameToCode.clear();
            Object.entries(payload ?? {}).forEach(([code, name]) => {
              registerFlagName(name, code);
            });
            applyFlagAliases();
            flagCodesLoaded = true;
            persistFlagCodes();
            updateHeroFlags(currentHeroMatch);
          } catch (error) {
            console.warn('No fue posible cargar los c√≥digos de banderas.', error);
          }
        };

        const applyEventArtwork = element => {
          if (!element) return;
          const eventName = element.dataset.eventName;
          if (!eventName) {
            element.style.removeProperty('--event-image');
            element.dataset.hasImage = 'false';
            return;
          }
          const imageUrl = getEventImageUrl(eventName);
          if (imageUrl) {
            element.style.setProperty('--event-image', `url("${imageUrl}")`);
            element.dataset.hasImage = 'true';
          } else {
            element.style.removeProperty('--event-image');
            element.dataset.hasImage = 'false';
          }
        };

        const refreshEventArtwork = () => {
          document.querySelectorAll('.trending-card, .matches-card').forEach(applyEventArtwork);
        };

        const setEventImage = (eventName, imageUrl) => {
          const normalized = normalizeEventName(eventName);
          if (!normalized) {
            console.warn('Nombre de evento inv√°lido para asignar imagen.');
            return false;
          }
          if (!imageUrl) {
            delete EVENT_IMAGE_MAP[normalized];
            persistEventImages();
            return true;
          }
          EVENT_IMAGE_MAP[normalized] = imageUrl;
          persistEventImages();
          return true;
        };

        const loadEventImages = async () => {
          if (loadEventImagesFromCache()) {
            console.info('Im√°genes de eventos recuperadas desde cach√© local.');
            refreshEventArtwork();
            updateBodyBackdrop(currentHeroMatch);
            updateHeroFlags(currentHeroMatch);
            return;
          }
          try {
            const response = await fetch(EVENT_IMAGES_ENDPOINT, { cache: 'no-store' });
            if (!response.ok) {
              throw new Error(`Estado ${response.status}`);
            }
            const payload = await response.json();
            const entries = Array.isArray(payload?.data) ? payload.data : [];
            if (entries.length) {
              clearObject(EVENT_IMAGE_MAP);
              entries.forEach(item => {
                const rawName = item?.evento ?? item?.event ?? item?.name;
                const imageUrl = item?.url ?? item?.image ?? null;
                const normalized = normalizeEventName(rawName);
                if (normalized && imageUrl) {
                  EVENT_IMAGE_MAP[normalized] = imageUrl;
                }
              });
              persistEventImages();
              console.info(
                `Im√°genes de eventos cargadas (${entries.length}). Usa smartVappEvents.setImage(nombre, url) para a√±adir o ajustar.`
              );
              refreshEventArtwork();
              updateBodyBackdrop(currentHeroMatch);
              updateHeroFlags(currentHeroMatch);
            }
          } catch (error) {
            console.warn('No fue posible cargar las im√°genes de eventos remotas.', error);
          }
        };

        window.smartVappEvents = Object.assign({}, window.smartVappEvents, {
          listEvents: () => [...observedCompetitions.values()],
          setImage: (eventName, imageUrl) => {
            const applied = setEventImage(eventName, imageUrl);
            if (applied) {
              refreshEventArtwork();
              updateBodyBackdrop(currentHeroMatch);
              updateHeroFlags(currentHeroMatch);
            }
            return applied;
          },
          refresh: () => {
            refreshEventArtwork();
            updateBodyBackdrop(currentHeroMatch);
            updateHeroFlags(currentHeroMatch);
          }
        });

        loadEventImages();

        const normalizeMatchName = description => {
          if (!description) return null;
          const segment = description.split(':').pop();
          return segment ? segment.replace(/\s+/g, ' ').trim() : null;
        };

        const extractCompetition = description => {
          if (!description) return null;
          const [competition] = description.split(':');
          return competition ? competition.replace(/\s+/g, ' ').trim() : null;
        };

        const formatTime = dateTime => {
          if (!(dateTime instanceof Date) || Number.isNaN(dateTime)) return null;
          return dateTime.toLocaleTimeString([], {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
        };

        const toAbsoluteUrl = path => {
          if (!path) return null;
          try {
            return new URL(path, API_URL).href;
          } catch {
            return path;
          }
        };

        const decodeEmbedUrl = iframePath => {
          if (!iframePath) return null;
          const absolute = toAbsoluteUrl(iframePath);
          let encoded = null;
          try {
            const urlObj = new URL(absolute);
            encoded = urlObj.searchParams.get('r');
          } catch {
            const match = iframePath.match(/[?&]r=([^&]+)/);
            if (match) encoded = match[1];
          }
          if (!encoded) return absolute;
          try {
            const base64 = decodeURIComponent(encoded);
            const decoded = atob(base64);
            if (decoded && decoded.startsWith('http')) {
              return decoded;
            }
            return absolute;
          } catch {
            return absolute;
          }
        };

        const parseEmbeds = attributes => {
          const items = attributes?.embeds?.data ?? [];
          return items
            .map(item => {
              const embedAttributes = item?.attributes ?? {};
              const iframePath = embedAttributes.embed_iframe ?? '';
              const decodedUrl = decodeEmbedUrl(iframePath);
              const fallbackUrl = toAbsoluteUrl(iframePath);
              return {
                id: item?.id ?? embedAttributes.embed_name ?? decodedUrl ?? fallbackUrl,
                name: embedAttributes.embed_name ?? 'Fuente',
                iframeUrl: fallbackUrl,
                url: decodedUrl ?? fallbackUrl
              };
            })
            .filter(embed => embed.url);
        };

        const createMatchesCard = (match, meta = {}) => {
          const card = document.createElement('article');
          card.className = 'matches-card';
          card.tabIndex = 0;

          const eventLabel = match.competition ?? match.country ?? null;
          if (eventLabel) {
            card.dataset.eventName = eventLabel;
          } else {
            delete card.dataset.eventName;
          }
          applyEventArtwork(card);

          const badgeText = typeof meta === 'object' ? meta.badge ?? '' : meta ?? '';
          const statusText = typeof meta === 'object' ? meta.status ?? '' : '';

          if (badgeText) {
            const badge = document.createElement('span');
            badge.className = 'matches-card-badge';
            badge.textContent = badgeText;
            card.append(badge);
          }

          const info = document.createElement('div');
          info.className = 'matches-card-info';

          const title = document.createElement('h3');
          title.className = 'matches-card-title';
          title.textContent = match.matchName ?? 'Partido';

          const subtitle = document.createElement('p');
          subtitle.className = 'matches-card-subtitle';
          subtitle.textContent =
            match.competition ??
            match.country ??
            'Competencia por confirmar';

          info.append(title, subtitle);
          card.append(info);

          if (statusText) {
            const status = document.createElement('span');
            status.className = 'matches-card-status';
            status.textContent = statusText;
            card.append(status);
          }

          if (statusText && /en vivo/i.test(statusText)) {
            card.classList.add('is-live');
          }

          return card;
        };

        const createTrendingCard = (match, meta = {}) => {
          const wrapper = document.createElement('div');
          wrapper.className = 'trending-card-wrapper';

          const card = document.createElement('article');
          card.className = 'trending-card';
          card.tabIndex = 0;
          wrapper.append(card);

          const eventLabel =
            meta.competition ?? match.competition ?? match.country ?? null;
          if (eventLabel) {
            card.dataset.eventName = eventLabel;
          } else {
            delete card.dataset.eventName;
          }
          applyEventArtwork(card);

          if (meta.badge) {
            const badge = document.createElement('span');
            badge.className = 'trending-card-badge';
            badge.textContent = meta.badge;
            card.append(badge);
          }

          if (meta.status) {
            const status = document.createElement('span');
            status.className = 'trending-card-status';
            status.textContent = meta.status;
            card.append(status);
          }

          const title = document.createElement('h3');
          title.className = 'trending-card-title';
          title.textContent = match.matchName ?? 'Partido';
          wrapper.append(title);

          const metaLine = document.createElement('p');
          metaLine.className = 'trending-card-meta';
          metaLine.textContent =
            meta.competition ??
            match.competition ??
            match.country ??
            'Competencia por confirmar';
          wrapper.append(metaLine);

          return wrapper;
        };

        const registerMatchElement = (element, match) => {
          if (!element || !match) return;
          if (element.classList.contains('matches-card') || element.classList.contains('trending-card')) {
            matchElementMap.set(element, match);
          }

          const nestedCards = element.querySelectorAll('.matches-card, .trending-card');
          nestedCards.forEach(cardEl => {
            matchElementMap.set(cardEl, match);
          });

          if (element.classList.contains('trending-card-wrapper')) {
            matchElementMap.set(element, match);
          }
        };

        const renderMatchList = (list, container, emptyLabel, options = {}) => {
          if (!container) return;
          const { metaResolver, cardFactory = createMatchesCard } = options;
          container.innerHTML = '';
          list.forEach(item => {
            const meta = metaResolver ? metaResolver(item) : {};
            const element = cardFactory(item, meta);
            registerMatchElement(element, item);
            container.append(element);
          });
          if (emptyLabel) {
            const hasItems = list.length > 0;
            emptyLabel.hidden = hasItems;
            emptyLabel.setAttribute('aria-hidden', String(hasItems));
          }
        };

        const fetchAndPopulateHero = async () => {
          if (!heroHeading) return;
          try {
            const response = await fetch(API_URL, { cache: 'no-store' });
            if (!response.ok) {
              throw new Error(`Respuesta inesperada: ${response.status}`);
            }

            const payload = await response.json();
            const entries = Array.isArray(payload?.data) ? payload.data : [];

            const now = new Date();
            const todayDate = now.toISOString().slice(0, 10);

            const matches = entries
              .map(entry => {
                const attributes = entry?.attributes ?? {};
                const date = attributes.date_diary ?? '';
                const hour = attributes.diary_hour ?? '';
                const dateTime = date && hour ? new Date(`${date}T${hour}`) : null;
                const rawDescription = attributes.diary_description ?? '';
                const countryName =
                  entry?.attributes?.country?.data?.attributes?.name ?? null;
                const competition = extractCompetition(rawDescription);
                if (competition) {
                  registerCompetition(competition);
                }
                return {
                  id:
                    entry?.id ??
                    `${attributes.diary_description ?? ''}-${date}-${hour}`.trim(),
                  matchName: normalizeMatchName(rawDescription),
                  competition,
                  dateTime,
                  date,
                  isFemenine: /femenina|femenino|women|femenil/i.test(rawDescription),
                  country: countryName,
                  embeds: parseEmbeds(attributes)
                };
              })
              .filter(match => match.matchName);

            if (observedCompetitions.size) {
              console.groupCollapsed('Eventos detectados');
              [...observedCompetitions.values()]
                .sort((a, b) => a.localeCompare(b, 'es'))
                .forEach(eventName => {
                  const imageUrl = getEventImageUrl(eventName);
                  console.log(
                    `%c${eventName}`,
                    'color:#8ab4ff;font-weight:600;',
                    imageUrl ? `Imagen asignada: ${imageUrl}` : 'Sin imagen configurada'
                  );
                });
              console.groupEnd();
              console.info(
                'Usa smartVappEvents.listEvents() para ver los eventos o smartVappEvents.setImage(nombre, url) para asignar una imagen.'
              );
            }

            matches.sort((a, b) => {
              if (a.dateTime && b.dateTime) return a.dateTime - b.dateTime;
              if (a.dateTime) return -1;
              if (b.dateTime) return 1;
              return 0;
            });
            availableMatches = matches.map(match => ({ ...match }));

            const sameDayUpcoming = matches.filter(match => {
              if (!match.dateTime || match.isFeminine) return false;
              if (match.date !== todayDate) return false;
              return match.dateTime >= now;
            });

            const liveMatches = matches.filter(match => {
              if (!match.dateTime || match.isFeminine) return false;
              if (match.date !== todayDate) return false;
              return (
                match.dateTime.getTime() <= now.getTime() &&
                now.getTime() - match.dateTime.getTime() <= 2 * 60 * 60 * 1000
              );
            });

            liveMatchesPool = liveMatches.map(match => ({ ...match }));

            let heroSource = null;
            const priorityLiveMatch = findPriorityMatch(liveMatches);
            if (priorityLiveMatch) {
              heroSource = priorityLiveMatch;
            } else if (liveMatches.length) {
              const randomLiveIndex = Math.floor(Math.random() * liveMatches.length);
              heroSource = liveMatches[randomLiveIndex];
            } else {
              const priorityUpcoming = findPriorityMatch(sameDayUpcoming);
              heroSource =
                priorityUpcoming ??
                sameDayUpcoming[0] ??
                matches.find(
                  match => match.dateTime && match.dateTime >= now && !match.isFeminine
                ) ??
                matches[0] ??
                null;
            }

            if (heroSource?.matchName) {
              const heroContext = computeHeroContext(heroSource, now);
              setHeroMatch(heroContext);
            }

            const liveIds = new Set(liveMatches.map(match => match.id));

            let trendingMatches = sameDayUpcoming.filter(match => !liveIds.has(match.id));
            if (!trendingMatches.length) {
              trendingMatches = matches
                .filter(
                  match =>
                    match.dateTime &&
                    !match.isFeminine &&
                    match.dateTime.getTime() >= now.getTime()
                )
                .sort((a, b) => {
                  if (a.dateTime && b.dateTime) return a.dateTime - b.dateTime;
                  if (a.dateTime) return -1;
                  if (b.dateTime) return 1;
                  return 0;
                });
            }

            renderMatchList(
            trendingMatches.slice(0, 4),
              trendingList,
              trendingEmpty,
              {
                metaResolver: match => ({
                  badge: match.dateTime ? formatTime(match.dateTime) : null,
                  status: 'Programado',
                  competition: match.competition ?? match.country ?? null
                }),
                cardFactory: createTrendingCard
              }
            );

            renderMatchList(
              liveMatches,
              liveList,
              liveEmpty,
              {
                metaResolver: match => ({
                  badge: match.dateTime ? formatTime(match.dateTime) : 'EN VIVO',
                  status: 'En vivo'
                })
              }
            );

            const dayMatches = matches
              .filter(match => match.date === todayDate && !match.isFeminine)
              .sort((a, b) => {
                if (a.dateTime && b.dateTime) return a.dateTime - b.dateTime;
                if (a.dateTime) return -1;
                if (b.dateTime) return 1;
                return 0;
              });

            renderMatchList(dayMatches, allList, allEmpty, {
              metaResolver: match => {
                const isLive = liveIds.has(match.id);
                if (isLive) {
                  return {
                    badge: match.dateTime ? formatTime(match.dateTime) : 'EN VIVO',
                    status: 'En vivo'
                  };
                }
                return {
                  badge: match.dateTime ? formatTime(match.dateTime) : 'Programado',
                  status: 'Programado'
                };
              }
            });

            refreshEventArtwork();
          } catch (error) {
            console.error('Error al cargar partidos desde la API:', error);
          }
        };

        loadTeamLogosFromCache();
        fetchFlagCodes();
        updateBodyBackdrop(currentHeroMatch);
        updateHeroFlags(currentHeroMatch);
        fetchAndPopulateHero();

        if (randomMatchButton) {
          randomMatchButton.addEventListener('click', () => {
            const candidate = pickRandomMatch();
            if (!candidate) {
              console.warn('No hay partidos disponibles para la prueba en este momento.');
              return;
            }
            setHeroMatch(candidate);
          });
        }

        const focusGroups = [
          { selector: 'header .brand-nav button' },
          { selector: 'header .profile button, header .profile .avatar' },
          { selector: '.hero-description .hero-action' },
          { selector: '.player-controls button' },
          { selector: '.player-sources button' },
          { selector: '.suggested-grid .trending-card' },
          { selector: '.live-section .matches-card' },
          { selector: '.all-section .matches-card' }
        ];

        const getGroupElements = index => {
          const group = focusGroups[index];
          if (!group) return [];
          return Array.from(document.querySelectorAll(group.selector)).filter(
            element => element.offsetParent !== null && getComputedStyle(element).visibility !== 'hidden'
          );
        };

        const getGroupIndexByElement = element =>
          focusGroups.findIndex(group =>
            Array.from(document.querySelectorAll(group.selector)).includes(element)
          );

        const playerSection = document.querySelector('.player-section');
        const watchButton = document.querySelector('.hero-action.primary');
        const playerReloadButton = playerSection?.querySelector('.player-controls .primary');
        const playerClose = playerSection?.querySelector('.player-close');
        const playerContainer = playerSection?.querySelector('[data-player-container]');
        const playerSourcesContainer = playerSection?.querySelector('[data-player-sources]');
        const playerMatchLabel = playerSection?.querySelector('[data-player-match]');
        const playerInfo = playerSection?.querySelector('.player-info');
        let playerInfoHideTimeout = null;

        const clearPlayerInfoHide = () => {
          if (playerInfoHideTimeout) {
            clearTimeout(playerInfoHideTimeout);
            playerInfoHideTimeout = null;
          }
        };

        const hidePlayerInfo = () => {
          if (!playerInfo) return;
          playerInfo.classList.add('is-hidden');
          playerInfo.setAttribute('aria-hidden', 'true');
        };

        const showPlayerInfo = ({ autoHide = false } = {}) => {
          if (!playerInfo) return;
          clearPlayerInfoHide();
          playerInfo.classList.remove('is-hidden');
          playerInfo.setAttribute('aria-hidden', 'false');
          if (autoHide) {
            playerInfoHideTimeout = window.setTimeout(() => {
              hidePlayerInfo();
            }, 5000);
          }
        };
        showPlayerInfo();

        const setLiveOpen = open => {
          if (!liveSection) return;
          liveSection.dataset.open = String(open);
          liveSection.setAttribute('aria-hidden', String(!open));
          document.body.classList.toggle('live-active', open);
          if (!open) {
            liveSection.scrollTop = 0;
          }
        };

        const openLiveSection = () => {
          if (!liveSection) return;
          setAllOpen(false);
          setPlayerOpen(false);
          setLiveOpen(true);
          const firstLiveCard = liveSection.querySelector('.trending-card, .matches-card');
          if (firstLiveCard) {
            firstLiveCard.focus();
          } else {
            liveCloseButton?.focus();
          }
        };

        const closeLiveSection = () => {
          if (!liveSection) return;
          setLiveOpen(false);
          openLiveButton?.focus();
        };
        const setAllOpen = open => {
          if (!allSection) return;
          allSection.dataset.open = String(open);
          document.body.classList.toggle('all-active', open);
        };

        const openAllSection = () => {
          if (!allSection) return;
          setLiveOpen(false);
          setPlayerOpen(false);
          setAllOpen(true);
          allSection.setAttribute('aria-hidden', 'false');
          const firstCard = allSection.querySelector('.matches-card');
          if (firstCard) {
            firstCard.focus();
          } else {
            allCloseButton?.focus();
          }
        };

        const closeAllSection = () => {
          if (!allSection) return;
          setAllOpen(false);
          allSection.setAttribute('aria-hidden', 'true');
          openAllButton?.focus();
        };

        const setPlayerOpen = open => {
          if (!playerSection) return;
          playerSection.dataset.open = String(open);
          playerSection.setAttribute('aria-hidden', String(!open));
          document.body.classList.toggle('player-active', open);
          if (open) {
            showPlayerInfo({ autoHide: true });
            playerSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
          } else {
            showPlayerInfo();
            clearPlayer();
          }
        };

        const clearPlayer = () => {
          if (playerMatchLabel) {
            playerMatchLabel.textContent = '';
          }
          if (playerContainer) {
            playerContainer.innerHTML = '';
          }
          if (playerSourcesContainer) {
            playerSourcesContainer.innerHTML = '';
          }
          currentPlayerMatch = null;
          currentPlayerSources = [];
          currentPlayerSourceIndex = 0;
        };

        const setPlayerSource = (embed, index = 0) => {
          if (!playerContainer) return;
          currentPlayerSourceIndex = index;
          playerContainer.innerHTML = '';

          if (embed && embed.url) {
            const iframe = document.createElement('iframe');
            iframe.src = embed.url;
            iframe.loading = 'lazy';
            iframe.allowFullscreen = true;
            iframe.referrerPolicy = 'no-referrer';
            playerContainer.append(iframe);
          } else {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'player-empty';
            emptyMessage.textContent = 'Fuentes no disponibles para este evento.';
            playerContainer.append(emptyMessage);
          }

          if (playerSourcesContainer) {
            const buttons = playerSourcesContainer.querySelectorAll('button');
            buttons.forEach((btn, idx) => {
              btn.classList.toggle('is-active', idx === index);
            });
          }
        };

        const renderPlayerSources = match => {
          if (!playerSourcesContainer) return;
          currentPlayerSources = Array.isArray(match?.embeds) ? match.embeds.filter(embed => embed?.url) : [];
          currentPlayerSourceIndex = 0;
          playerSourcesContainer.innerHTML = '';

          if (!currentPlayerSources.length) {
            playerSourcesContainer.textContent = 'No hay fuentes disponibles';
            setPlayerSource(null);
            return;
          }

          currentPlayerSources.forEach((embed, idx) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.textContent = embed.name ?? `Fuente ${idx + 1}`;
            button.addEventListener('click', () => {
              currentPlayerSourceIndex = idx;
              setPlayerSource(embed, idx);
            });
            if (idx === 0) {
              button.classList.add('is-active');
            }
            playerSourcesContainer.append(button);
          });

          setPlayerSource(currentPlayerSources[0], 0);
        };

        const openPlayer = match => {
          if (!playerSection) return;
          const targetMatch = match ?? currentHeroMatch;
          if (!targetMatch) return;
          clearPlayer();
          setLiveOpen(false);
          setAllOpen(false);
          setPlayerOpen(true);
          currentPlayerMatch = targetMatch;
          updateBodyBackdrop(targetMatch);
          updateHeroFlags(targetMatch);
          if (playerMatchLabel) {
            playerMatchLabel.textContent = targetMatch.matchName ?? '';
          }
          renderPlayerSources(targetMatch);
          const firstSourceButton = playerSourcesContainer?.querySelector('button');
          if (firstSourceButton) {
            firstSourceButton.focus();
          } else {
            playerReloadButton?.focus();
          }
        };

        const closePlayer = ({ restoreFocus = true } = {}) => {
          if (!playerSection) return;
          setPlayerOpen(false);
          updateBodyBackdrop(currentHeroMatch);
          updateHeroFlags(currentHeroMatch);
          if (restoreFocus) {
            watchButton?.focus();
          }
        };

        document.addEventListener('keydown', event => {
          const { key } = event;

          if (focusAllGrid(event)) {
            return;
          }

          if (key === 'Escape') {
            if (document.body.classList.contains('player-active')) {
              event.preventDefault();
              closePlayer();
              return;
            }
            if (document.body.classList.contains('all-active')) {
              event.preventDefault();
              closeAllSection();
              return;
            }
            if (document.body.classList.contains('live-active')) {
              event.preventDefault();
              closeLiveSection();
              return;
            }
          }
          if (!['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp'].includes(key)) return;

          if (
            document.body.classList.contains('player-active') &&
            playerSection?.contains(document.activeElement)
          ) {
            showPlayerInfo({ autoHide: true });
          }

          const active = document.activeElement;
          if (!active) return;

          let groupIndex = getGroupIndexByElement(active);
          if (groupIndex === -1) {
            const firstGroupElements = getGroupElements(0);
            if (firstGroupElements.length) firstGroupElements[0].focus();
            return;
          }

          const currentGroup = getGroupElements(groupIndex);
          const currentIndex = currentGroup.indexOf(active);
          if (currentIndex === -1) return;

          if (key === 'ArrowLeft' || key === 'ArrowRight') {
            event.preventDefault();
            const direction = key === 'ArrowRight' ? 1 : -1;
            let nextIndex = currentIndex + direction;

            if (groupIndex === 0 && direction === 1 && nextIndex >= currentGroup.length) {
              const profileGroup = getGroupElements(1);
              if (profileGroup.length) {
                profileGroup[0].focus();
                return;
              }
            }

            if (groupIndex === 1 && direction === -1 && nextIndex < 0) {
              const navGroup = getGroupElements(0);
              navGroup[navGroup.length - 1].focus();
              return;
            }

            nextIndex = Math.max(0, Math.min(nextIndex, currentGroup.length - 1));
            currentGroup[nextIndex].focus();
            return;
          }

          if (groupIndex < 2 && key === 'ArrowUp') {
            event.preventDefault();
            return;
          }

          if (key === 'ArrowDown') {
            event.preventDefault();

            const activeGroups = [...focusGroups];
            if (!document.body.classList.contains('live-active')) {
              activeGroups.splice(activeGroups.findIndex(g => g.selector === '.live-section .matches-card'), 1);
            }
            if (!document.body.classList.contains('all-active')) {
              activeGroups.splice(activeGroups.findIndex(g => g.selector === '.all-section .matches-card'), 1);
            }

            if (groupIndex === 0 || groupIndex === 1) {
              const heroActions = getGroupElements(2);
              if (heroActions.length) {
                heroActions[0].focus();
                return;
              }
            }

            let nextGroupIndex = groupIndex + 1;
            while (nextGroupIndex < activeGroups.length) {
              const targetGroup = Array.from(document.querySelectorAll(activeGroups[nextGroupIndex].selector)).filter(
                element => element.offsetParent !== null && getComputedStyle(element).visibility !== 'hidden'
              );
              if (targetGroup.length) {
                targetGroup[Math.min(currentIndex, targetGroup.length - 1)].focus();
                break;
              }
              nextGroupIndex += 1;
            }
            return;
          }

          if (key === 'ArrowUp') {
            event.preventDefault();
            let prevGroupIndex = groupIndex - 1;
            const minIndex = 0;
            const filteredGroups = [...focusGroups];
            if (!document.body.classList.contains('live-active')) {
              filteredGroups.splice(filteredGroups.findIndex(g => g.selector === '.live-section .matches-card'), 1);
            }
            if (!document.body.classList.contains('all-active')) {
              filteredGroups.splice(filteredGroups.findIndex(g => g.selector === '.all-section .matches-card'), 1);
            }
            while (prevGroupIndex >= minIndex) {
              const targetGroup = Array.from(document.querySelectorAll(filteredGroups[prevGroupIndex].selector)).filter(
                element => element.offsetParent !== null && getComputedStyle(element).visibility !== 'hidden'
              );
              if (targetGroup.length) {
                targetGroup[Math.min(currentIndex, targetGroup.length - 1)].focus();
                break;
              }
              prevGroupIndex -= 1;
            }
          }
        });

        const firstNav = document.querySelector('header .brand-nav button');
        if (firstNav) firstNav.focus();

        watchButton?.addEventListener('click', event => {
          event.preventDefault();
          openPlayer(currentHeroMatch);
        });

        playerReloadButton?.addEventListener('click', () => {
          if (!currentPlayerSources.length) return;
          const source =
            currentPlayerSources[currentPlayerSourceIndex] ?? currentPlayerSources[0];
          setPlayerSource(source, currentPlayerSourceIndex);
        });

        playerClose?.addEventListener('click', () => closePlayer());
        openAllButton?.addEventListener('click', event => {
          event.preventDefault();
          openAllSection();
        });
        allCloseButton?.addEventListener('click', event => {
          event.preventDefault();
          closeAllSection();
        });
        openLiveButton?.addEventListener('click', event => {
          event.preventDefault();
          openLiveSection();
        });
        liveCloseButton?.addEventListener('click', event => {
          event.preventDefault();
          closeLiveSection();
        });

        const closeAllOverlays = () => {
          if (document.body.classList.contains('player-active')) {
            closePlayer({ restoreFocus: false });
          }
          setLiveOpen(false);
          setAllOpen(false);
        };

        const navButtons = document.querySelectorAll('header .brand-nav button');

        const setNavActive = activeButton => {
          navButtons.forEach(btn => btn.classList.toggle('is-active', btn === activeButton));
        };

        navButtons.forEach(button => {
          button.addEventListener('click', () => {
            setNavActive(button);
          });

          if (!button.dataset.action) {
            button.addEventListener('click', () => {
              closeAllOverlays();
            });
          }
        });

        const focusAllGrid = event => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return false;
          if (!target.matches('.all-section .matches-card')) return false;

          const grid = target.closest('.matches-grid');
          if (!grid) return false;

          const cards = Array.from(grid.querySelectorAll('.matches-card')).filter(card => card.offsetParent !== null);
          const index = cards.indexOf(target);
          if (index === -1) return false;

          const templateColumns = window
            .getComputedStyle(grid)
            .getPropertyValue('grid-template-columns')
            .trim();
          const columnCount = templateColumns
            ? templateColumns.split(/\s+/).filter(value => value !== '/').length || 1
            : 1;

          const moveFocus = newIndex => {
            if (newIndex >= 0 && newIndex < cards.length) {
              cards[newIndex].focus();
              return true;
            }
            return false;
          };

          switch (event.key) {
            case 'ArrowRight':
              if (moveFocus(index + 1)) {
                event.preventDefault();
                return true;
              }
              break;
            case 'ArrowLeft':
              if (moveFocus(index - 1)) {
                event.preventDefault();
                return true;
              }
              break;
            case 'ArrowDown':
              if (moveFocus(index + columnCount)) {
                event.preventDefault();
                return true;
              }
              break;
            case 'ArrowUp':
              if (index < columnCount) {
                const navButton = document.querySelector('header .brand-nav button[data-action="open-all"]');
                if (navButton) {
                  navButton.focus();
                  event.preventDefault();
                  return true;
                }
              } else if (moveFocus(index - columnCount)) {
                event.preventDefault();
                return true;
              }
              break;
            default:
              break;
          }

          return false;
        };

        const getMatchFromEvent = target => {
          if (!(target instanceof HTMLElement)) return null;
          const card = target.closest('.matches-card, .trending-card, .trending-card-wrapper');
          if (!card) return null;
          return matchElementMap.get(card) ?? null;
        };

        document.addEventListener('click', event => {
          const match = getMatchFromEvent(event.target);
          if (match) {
            event.preventDefault();
            openPlayer(match);
          }
        });

        document.addEventListener('keydown', event => {
          if (!['Enter', ' '].includes(event.key)) return;
          const match = getMatchFromEvent(event.target);
          if (match) {
            event.preventDefault();
            openPlayer(match);
          }
        }, true);
      })();
    </script>
  </body>
</html>

